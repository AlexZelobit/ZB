# Инструкция
*git config --globa user.name
*git config --global.email
## Клавиши
> Q - выход с терминала, если он не отвечает
> Ctrl+S Сохранение перед работой в терминале
> cd <название папки> - переход между папками
## Основные команды
* git init* - инициализация репозитория
* git status* - вывод статуса репозитория на момент времени
* git add* - добавление файлу версионности
* git commit -m <message>* - фиксация изменений
* git log* - вывод журнала изменений
* git diff* - вывод изменений по сравнению с предыдущим commit
* git checkout (хэш-номер коммита)* - перемещение к определенному коммиту
> git checkout <имя ветки>^номер родителя
* git checkout master* - перемещение к актуальному состоянию
* git cherry-pick — отменить изменения. Например, если коммит попал в ветку по ошибке, вы можете переключиться на нужную ветку и выполнить перенос.
* git reset - позволяет сбросить состояние проекта до какого-либо коммита в истории.
* git revert – безопасный способ отменить операцию без потери истории коммитов. Команда отменяет действия прошлых коммитов, создавая новый, содержащий все отменённые изменения.
* git rebase — это открепить ветку (branch), которую вы хотите переместить, и подключить ее к другой ветке. 
> git rebase <название куда перенести> <название ветку которую переносим>
* git tag v1 c1 - делаем тег на с1
* git describe <ref> - просмотр версии комита
* git fetch - скачивает нове данные в локальный репозиторий
## Команды для веток (branch)
* git branch - просмотр веток
* git branch <...>- создание ветки
* git checkout -b <...> - создать новую ветку и переключиться на нее
* git checkout <...> - переключиться на другую ветку
* git merge <...> - слияние с веткой
* git branch -d <...> - удаление ветки
* git log --graph - просмотр дерева веток
* git merge lists - в текущую ветку добавится информацию из ветки lists
* git branch -m <...>  - переименовать текущую ветку
* git branch -m 1_seminar second_seminar - переименование одной ветки в другую
* git remote add origin https://github.com/AlexZelobit/zbv2.git - удаленно подключаемся к репозиторию
* git branch -M main - переименовываем мастер в main
* git pull - скачиваем файлы на свой пк
* git push -u origin main - перекачиваем на удаленный репозиторий файлы
* git clone https://github.com/ilnar-geekbrains/group_903/ - копируем удаленный репозиторий
.gitignore - создание файла для игнорирования файлов и картинок
## Стили оформления
*Крсивный текст выделяется звездочкой* или _Нижним подчеркиванием_
**Полужирный текст двумя звездочками а наклонный с _нижним подчеркиванием_**
## Заголовки
H1 - #
H2 - ##
H3 -###
## Списки
* Не нумерованный список звездочка с пробелом
    * Вложенные списки используют tab
        1. Нумерованные списки цифры с точкой
        1. Могут даже с еденицы ничинаться
## Ссылки
[Анкорная ссылка в квадратных скобках анкор в круглыс ссылка](https://gb.ru/)
![Ссылка на картинку также, только добавяется !](https://git-scm.com/images/logo@2x.png)
## Цитаты
> Цитаты выделяются знаком >

## Learn GIT
* Перемещение на один коммит назад ^
* Чтобы переключиться на прошлый commit нужна комманда _git checkout head^_
* Перемещение на несколько коммитов назад _git checkout (название сомита)~<num>_
* прикрепить ветку к комиту  _git branch -f main HEAD~3_
### L2
* git reset - отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.
* git revert - Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert.

### L3

git cherry-pick <Commit1> <Commit2> <...> - если хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD).
* rebase — это открепить ветку (branch), которую вы хотите переместить, и подключить ее к другой ветке.
* git rebase -i head~4
Всё, что нужно для интерактивного rebase - это опция -i
Если добавить эту опцию, Git откроет интерфейс просмотра того, какие коммиты готовы к копированию на цель rebase (target). Также показываются хеши коммитов и комментарии к ним, так что можно легко понять что к чему.
        * Надо перенести данные с одного комита в основной и сделать
        git rebase -i с1
        git rebase bugFix(куда) main(что) - делаем коммит основным

### L4

Вот ещё одна ситуация, которая часто случается. Есть некоторые изменения (newImage) и другие изменения (caption), которые связаны так, что находятся друг поверх друга в репозитории.

Штука в том, что иногда нужно внести небольшие изменения в более ранний коммит. В таком случае надо немного поменять newImage, несмотря на то, что коммит уже в прошлом!


Если нужно внести изменения в ранний commit надо:
Переставить коммит так, чтобы нужный находился наверху при помощи git rebase -i
Внести изменения при помощи git commit --amend
Переставить всё обратно при помощи git rebase -i
И наконец, переместить main на изменённую часть дерева, чтобы закончить уровень.

Обрати внимание на итоговое состояние в этом уровне – так как мы дважды перемещаем коммиты, оба они получат по апострофу. Ещё один апостроф добавляется, когда мы делаем git commit --amend.

Важно, чтобы совпадало не только дерево коммитов, но и количество апострофов.
### L5
В прошлом уровне мы использовали rebase -i, чтобы переставлять коммиты. Как только нужный нам коммит оказывался в конце, мы могли спокойно изменить его при помощи --amend и переставить обратно.

Единственная проблема тут - это множество перестановок, которые могут спровоцировать конфликты. Посмотрим, как с этой же задачей справится cherry-pick.

### L6
Склонируйте удалённый репозиторий (с помощью git clone), симулируйте любые изменения на этом удалённом репозитории, сделайте какие-нибудь свои коммиты и затем скачайте "чужие" изменения. Это выглядит как несколько уроков в одном!
fakeTeamwork
get fetch - скачиваем изменения с сервера
git rebase o/main
git push
git pull --rebase

Склонируйте репозиторий
Сфабрикуйте командную работу (1 коммит)
Сделайте свой собственный коммит (1 коммит)
Опубликуйте свои наработки посредством перебазировки (rebasing)

Рабочий процесс получения изменений (fetching), 
перебазирования/объединения (rebase/merging) 
публикации изменений (pushing)

### L8
Создайте ещё одну ветвь под названием feature и отправьте изменения на удалённый репозиторий. Также не забудьте вернуть вашу локальную main ветвь в исходное состояние (чтобы она была синхронизирована с удалённой). В противном случае у вас могут возникнуть проблемы при следующем выполнении git pull.
git checkout -b feature c2 - создание ветви в коммите с2
git push origin feature 
### L9
git pull --rebase - скачиваем с сервера версию и объдиняем с нашей
Есть три фича-бранчи (фича-ветки) - side1 side2 и side3
Нам необходимо закачать каждую из них по очереди на удалённый репозиторий
При этом удалённый репозиторий хранит в себе какие-то наработки, которые также следует скачать к себе

### L10

git checkout -b totallyNotMain o/main

git branch -u o/main foo

git branch -u o/main

Отлично! Для выполнения этого уровня давайте выполним push наших наработок в ветку main на удалённом репозитории, при этом не скачивая и не создавая ветку main локально. Я объясню вам оставшееся чуть позже, т.к. это продвинутый курс :P

### L11

Когда вы работаете в составе большой команды разработчиков над проектом, то, вероятнее всего, ветвь main будет заблокирована. Для внесения изменений в неё в git существует понятие запроса на слияние Pull Request. В такой ситуации если вы закоммитите свои наработки непосредственно в main ветвь, а после выполните git push, то будет сгенерировано сообщение об ошибке:

! [remote rejected] main -> main (TF402455: Pushes to this branch are not permitted; you must use a pull request to update this branch.)
! [удалённо отклонено] main -> main (TF402455: Изменение этой ветви запрещены; вы можете использовать pull request для обновления этой ветви.)

git reset --hard o/main - отмена изменений до o/main

git push <удалённый_репозиторий> <целевая_ветка>

### L12

git push origin main - перенсим в облако конкретные соммиты
git push origin <источник>:<получатель>

### L13
git fetch origin foo~1:bar
git push origin :foo - удаляет коммит в ветке в локальном и удаленном репозитории
git fetch origin :bar - создаст ветку

### L14

git pull origin foo это то же самое, что сделать:

git fetch origin foo; git merge o/foo

И еще...

git pull origin bar~1:bugFix то же, что:

git fetch origin bar~1:bugFix; git merge bugFix

Как видно, git pull используется, чтобы за одну команду выполнить fetch + merge.

В последнем упражнении необходимо привести дерево к аналогичному в примере. Нужно скачать несколько изменений, создать несколько новых веток, слить одни ветки в другие, но постарайтесь использовать как можно меньше команд. Удачи! :P